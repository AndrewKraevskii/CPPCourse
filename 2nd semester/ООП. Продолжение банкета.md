#	ООП. Продолжение банкета

[TOC]

##	Наследование

###	Пресловутые три кита

Вся парадигма ООП “держится” на трех принципах:

- ***Инкапсуляция***

  С инкапсуляций вы познакомились при изучении модификаторов доступа. Если говорить просто, то инкапсуляция гарантирует одновременно сохранность данных от внешнего вмешательства и хранение их в одном компоненте/“сущности”/объекте вместе с функциями (**методы**), которые эти данные обрабатывают.

  Пример: У каждого котика внутри вашей программы будет свой вес, возраст, любимый корм и т.д.

- ***Наследование***

  Концепция, согласно которой типы данных могут наследовать поведение (свойства и признаки) других сущностей.

  Пример: Волк слабее льва и тигра, но наследуются они все от класса Animal, а значит имеют вес, возраст, способность издавать звуки и т.д.

- ***Полиморфизм***

  Способность одной функции (и не только) обрабатывать данные нескольких типов без перегрузки.

  Пример: Блендер для приготовления жижи принимает вектор из Product, но положить в него можно разных наследников этого самого Product.

### Так что же с наследованием?

В контексте С++ при создании класса **наследника** необходимо будет указать класс **родитель**.

```C++
class Device {
    public:
        int serialNumber = 12345678;

        void turnOn() {
            cout << "Device is on" << endl;
        }
    private:
        int mPincode = 87654321;
};

class Computer: public Device {
    // Здесь можно добавлять новый функционал на базе Device
};

int main() {
    Computer сomputerInstance;

    сomputerInstance.turnOn();
    cout << "Serial number is: " << Computer_instance.serialNumber << endl;
    return 0;
}
```



##	Модификаторы наследования

У наследование тоже есть модификаторы доступа. Пример сверху с модификатором `public`.

В чем же разница?


| Модификатор поля/метода у родителя | Модификатор наследования | Модификатор поля/метода у наследника |
| :-------------------------: | :----------------------: | :---------------------------: |
|           public            | ***public*** | public |
|           private           |          ***public***          | no access |
|          protected          | ***public*** | protected |
|           public            | ***private*** | private |
|           private           |         ***private***          | no access |
|          protected          | ***private*** | private |
|           public            | ***protected*** | protected |
|           private           |        ***protected***         | no access |
|          protected          | ***protected*** | protected |

##	Наследование конструкторов

В C ++ конструкторы и деструкторы не наследуются. Однако они вызываются **самостоятельно**, когда дочерний класс инициализирует свой объект. Конструкторы по-умолчанию вызываются один за другим иерархически, начиная с базового класса и  заканчивая последним производным классом. Деструкторы вызываются в **обратном** порядке.

Если же требуется вызвать конструктор с непустым набором параметров, то необходимо указать вызов родительского конструктора вручную.

```C++
class Computer {
    public:
    	Computer(int id): serialId(id){}
	private:
    	int serialId = 0;
};

class Laptop: public Computer {
    public:
    	Laptop(int id): Computer(id){}
};
```



###	Множественное наследование

В С++ класс наследник может иметь два и более суперкласса (родителя).

```C++
class Computer {
    public:
        void turnOn() {
            cout << "Welcome to Windows 95" << endl;
        }
};

class Monitor {
    public:
        void showImage() {
            cout << "Imagine image here" << endl;
        }
};

class Laptop: public Computer, public Monitor {};

int main() {
    Laptop laptopInstance;
    laptopInstance.turnOn();
    laptopInstance.showImage();
    return 0;
}
```

### Проблема ромба

Проблема ромба (Diamond problem)- классическая проблема в языках,  которые поддерживают возможность множественного наследования. Эта  проблема возникает когда классы `B` и `C` наследуют `A`, а класс `D` наследует `B` и `C`.



К примеру, классы `A`, `B` и `C` определяют метод `print_letter()`. Если `print_letter()` будет вызываться классом `D`, неясно какой метод должен быть вызван — метод класса `A`, `B` или `C`. Разные языки по-разному подходят к решению ромбовидной проблем. В C ++ решение проблемы оставлено на усмотрение программиста.

 Ромбовидная проблема — прежде всего проблема дизайна, и она должна быть предусмотрена на этапе проектирования. 

```C++
class Device {
    public:
        void turnOn() {
            cout << "Device is on." << endl;
        }
};

class Computer: public Device {
    public:
        void turnOn() {
            cout << "Computer is on." << endl;
        }
};

class Monitor: public Device {
    public:
        void turnOn() {
            cout << "Monitor is on." << endl;
        }
};

class Laptop: public Computer, public Monitor {
    /*
    public:
        void turn_on() {
            cout << "Laptop is on." << endl;
        }
    // uncommenting this function will resolve diamond problem
    */
};

int main() {
    Laptop laptopInstance;

    // Laptop_instance.turn_on();
    // will produce compile time error
    // if Laptop.turn_on function is commented out

    // calling method of specific superclass
    laptopInstance.Monitor::turnOn();
    return 0;
}
```

Поскольку в С++ при инициализации объекта дочернего класса вызываются  конструкторы всех родительских классов, возникает и другая проблема:  конструктор базового класса `Device` будет вызван дважды.

## Virtual и переопределение

Логично, что если классы могут наследовать родительские свойства, то они могут и менять его.

В предыдущем примере это уже было показано.

Кроме модификаторов доступа у полей и методов могут быть другие модификаторы.

Один из таких - **virtual**.

Этот модификатор метода говорит о том, что классу наследнику будет необходимо реализовать собственную реализацию.

Чаще всего он используется при написании интерфейсов, абстрактных классов.

**Virtual** можно использовать для решения проблемы двойного вызова конструктора при множественном наследовании.

Виртуальное наследование (virtual inheritance) предотвращает  появление множественных объектов базового класса в иерархии  наследования. Таким образом, конструктор базового класса `Device` будет вызван только единожды, а обращение к методу `turnOn()` без его переопределения в дочернем классе не будет вызывать ошибку при компиляции.

```C++
class Computer: virtual public Device {};

class Monitor: virtual public Device {};

class Laptop: public Computer, public Monitor {};
 
int main() {
    Laptop laptopInstance;
    laptopInstance.turnOn();
    return 0;
}
```

##	Операторы + Friend