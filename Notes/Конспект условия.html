<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Конспект условия</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h1 id="основные-понятия-булевой-логики.">Основные понятия булевой логики.</h1>
<ul>
<li><a href="#basic_logic">Основные логические операции </a>
<ul>
<li><a href="#NOT">NOT</a></li>
<li><a href="#AND">AND</a></li>
<li><a href="#OR">OR</a></li>
<li><a href="#IMPL">Импликация</a></li>
<li><a href="#EQ">Equals</a></li>
<li><a href="#XOR">XOR</a></li>
</ul>
</li>
<li><a href="#tables">Булевы тождества и их проверка. Таблицы истинности.</a></li>
<li><a href="#laws">Законы булевой логики (свойства логических операций).</a></li>
<li><a href="#memory">Представление целых чисел в памяти компьютера. </a>
<ul>
<li><a href="#overflow">Переполнение</a></li>
<li><a href="#integers">Битовые операции над целыми числами и их применения.</a></li>
</ul>
</li>
<li><a href="#if">Условный оператор.</a>
<ul>
<li><a href="#if-else">Конструкции if и if else.</a></li>
<li><a href="#if-if">Вложенные условные операторы.</a></li>
<li><a href="#if-and-or">Объединение условий (and, or, not).</a></li>
<li><a href="#if-opt">Оптимизация логических выражений компилятором (false and X, true or Y).</a></li>
<li><a href="#case">Оператор Case.</a></li>
</ul>
</li>
</ul>
<h2 id="основные-логические-операции-a-name--basic_logica">Основные логические операции <a></a></h2>
<p>Все логические операции в контексте C++ применимы исключительно для значений с <strong>логическим</strong> типом данных — <code>bool</code>. В случае, когда в условии или логическом выражении оказывается тип данных отличный от логического, язык будет пытаться приводить используемый тип к <code>bool</code> (иногда успешно, а иногда нет).</p>
<h3 id="nota-name--nota">NOT<a></a></h3>
<p>Логическая операция <code>НЕ</code> представима в виде оператора <code>!</code>.  Эта операция “отрицает” значение которое вы ей передаёте.<br>
Таблица истинности будет выглядеть подобным  образом:</p>

<table>
<thead>
<tr>
<th>X</th>
<th>!X</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table><p>Рассмотрим фрагмент кода с примерами работы:</p>
<pre><code>cout &lt;&lt; (!true); //false
cout &lt;&lt; (!(!true));//true
cout &lt;&lt; (!(10 &gt; 5));//false
</code></pre>
<h3 id="and-a-name--anda">AND <a></a></h3>
<p>Логическая операция <code>И</code> представима в виде оператора <code>&amp;&amp;</code>. Для этой операции существует <strong>единственный</strong> набор входных параметров, при котором она принимает значение <code>ИСТИНА</code> . Это набор, в котором оба параметра <strong>истинны</strong>.<br>
Таблица истинности будет выглядеть подобным  образом:</p>

<table>
<thead>
<tr>
<th>X</th>
<th>Y</th>
<th>X &amp;&amp; Y</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table><p>Рассмотрим фрагмент кода с примерами работы:</p>
<pre><code>cout &lt;&lt; (true &amp;&amp; false); //false
cout &lt;&lt; (true &amp;&amp; !false);//true
cout &lt;&lt; ((10 &gt; 5) &amp;&amp; 1);//true
cout &lt;&lt; ((x &gt; 5) &amp;&amp; (x &lt;= 5));//false
</code></pre>
<h3 id="or-a-name--ora">OR <a></a></h3>
<p>Логическая операция <code>ИЛИ</code> представима в виде оператора <code>||</code>. Для этой операции существует <strong>единственный</strong> набор входных параметров, при котором она принимает значение <code>ЛОЖЬ</code> . Это набор, в котором оба параметра <strong>ложны</strong>.<br>
Таблица истинности будет выглядеть подобным  образом:</p>

<table>
<thead>
<tr>
<th>X</th>
<th>Y</th>
<th>X || Y</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table><p>Рассмотрим фрагмент кода с примерами работы:</p>
<pre><code>cout &lt;&lt; (true || false); //true
cout &lt;&lt; (true || !false);//true
cout &lt;&lt; (!(10 &gt; 5) || 0);//false
cout &lt;&lt; ((x &gt; 5) || (x &lt;= 5));// true
</code></pre>
<h3 id="импликация-a-name--impla">Импликация <a></a></h3>
<p>В C++ на примитивном уровне не реализована, но легко заменяется с помощью выражения <code>!X OR Y</code>.  Эта операция выполняет функцию операции <code>следовательно</code>. Из <code>X</code> следует <code>Y</code>. Если верен <code>X</code>, то верен должен быть и <code>Y</code>. Если <code>X</code> ложен, то <code>Y</code> может быть любым.</p>
<blockquote>
<p>Из истины может следовать только истина, а из лжи всё что угодно.</p>
</blockquote>
<p>Таблица истинности будет выглядеть подобным  образом:</p>

<table>
<thead>
<tr>
<th>X</th>
<th>Y</th>
<th>X -&gt; Y</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table><h3 id="equals-a-name--eqa">Equals <a></a></h3>
<p>Логическая операция <code>РАВНО</code> представима в виде оператора <code>==</code>.  Суть операции в совпадении значений двух параметров, которые в неё передаются.  Отрицание эквивалентности можно записать как <code>!=</code>.<br>
Таблица истинности будет выглядеть подобным  образом:</p>

<table>
<thead>
<tr>
<th>X</th>
<th>Y</th>
<th>X == Y</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table><p>Рассмотрим фрагмент кода с примерами работы:</p>
<pre><code>cout &lt;&lt; (true == false); //false
cout &lt;&lt; (true == !false);//true
cout &lt;&lt; ((10 &gt; 5) == 1);//true
cout &lt;&lt; ((x &gt; 5) != (x &lt;= 5));//true
</code></pre>
<h3 id="xor-a-name--xora">XOR <a></a></h3>
<p>Логическая операция <code>ИСКЛЮЧАЮЩЕЕ ИЛИ</code> представима в виде оператора <code>^</code>.  Для корректного  использования этой операции в логических выражениях <em><strong>нужно использовать только логические типы или приведение</strong></em>. Суть операции в том, что значение только одного параметра может быть истинным.<br>
Таблица истинности будет выглядеть подобным  образом:</p>

<table>
<thead>
<tr>
<th>X</th>
<th>Y</th>
<th>X ^ Y</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table><p>Рассмотрим фрагмент кода с примерами работы:</p>
<pre><code>cout &lt;&lt; (true ^ false); //true
cout &lt;&lt; (true ^ !false);//false
cout &lt;&lt; ((10 &gt; 5) ^ bool(25));//false
cout &lt;&lt; ((x &gt; 5) ^ (x &lt;= 5));//false
</code></pre>
<h2 id="булевы-тождества-и-их-проверка.-таблицы-истинности.a-name--tablesa">Булевы тождества и их проверка. Таблицы истинности.<a></a></h2>
<p>При написании собственных булевых тождеств или функций необходимо делать проверку. Её осуществляют с помощью таблицы истинности. Такая таблица содержит в себе все возможные значения параметров и функции/тождества.<br>
Рассмотрим таблицу для функции <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo>=</mo><msub><mi>X</mi><mn>1</mn></msub><mi>a</mi><mi>n</mi><mi>d</mi><msub><mi>X</mi><mn>2</mn></msub><mi>o</mi><mi>r</mi><msub><mi>X</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">F = X_1andX_2orX_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.13889em;">F</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.84444em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.07847em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.07847em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right: 0.02778em;">r</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: -0.07847em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span></p>

<table>
<thead>
<tr>
<th>X<sub>1</sub></th>
<th>X<sub>2</sub></th>
<th>X<sub>3</sub></th>
<th>F</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table><h2 id="законы-булевой-логики-свойства-логических-операций.a-name--lawsa">Законы булевой логики (свойства логических операций).<a></a></h2>
<p>Основными законами считаются:</p>
<ul>
<li>Закон двойного отрицания <code>!(!A) == A</code></li>
<li>Коммутативность <code>A (|| &amp;&amp;) B == B (|| &amp;&amp;) A</code></li>
<li>Ассоциативность <code>A (|| &amp;&amp;) (B (|| &amp;&amp;) C) == (A (|| &amp;&amp;) B) (|| &amp;&amp;) C</code></li>
<li>Дистрибутивность	<code>A (|| &amp;&amp;) (B (&amp;&amp; ||) C) == (A (|| &amp;&amp;) B) (&amp;&amp; ||) (A (|| &amp;&amp;) C)</code></li>
<li>Правило де Моргана <code>!A (&amp;&amp; ||) !B == !(A (|| &amp;&amp;) B)</code></li>
<li>и т. д.</li>
</ul>
<p>Будьте <a href="https://habr.com/ru/company/pvs-studio/blog/281316/">ВНИМАТЕЛЬНЫ</a> при составлении и упрощении ваших условий.</p>
<h2 id="представление-целых-чисел-в-памяти-компьютера.-a-name--memorya">Представление целых чисел в памяти компьютера. <a></a></h2>
<p>Большинство современных компьютеров используют двоичную логику и  производят вычисления в <strong>двоичной системе счисления</strong>.<br>
Типичное число в двоичной системе выглядит так: <code>1110 1111</code>.<br>
Перевод из двоичной в десятичную и обратно выполняется очень просто.<br>
Значение при переводе вычисляется по формуле: <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>i</mi></msup><msub><mi>k</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">2^{i}{k_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.974664em; vertical-align: -0.15em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.824664em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.311664em;"><span class="" style="top: -2.55em; margin-left: -0.03148em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span></span>, где k – значение бита, а i – позиция бита в числе.</p>

<table>
<thead>
<tr>
<th>Позиция бита</th>
<th>Значение бита</th>
<th>Значение при переводе</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>8</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
<td>32</td>
</tr>
<tr>
<td>6</td>
<td>1</td>
<td>64</td>
</tr>
<tr>
<td>7</td>
<td>1</td>
<td>128</td>
</tr>
</tbody>
</table><p>Значение числа <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1110111</mn><msub><mn>1</mn><mn>2</mn></msub><mo>=</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>8</mn><mo>+</mo><mn>0</mn><mo>+</mo><mn>64</mn><mo>+</mo><mn>128</mn><mo>=</mo><mn>23</mn><msub><mn>9</mn><mn>10</mn></msub></mrow><annotation encoding="application/x-tex">11101111_2=1+2+4+8+0+64+128 =239_{10}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.79444em; vertical-align: -0.15em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.79444em; vertical-align: -0.15em;"></span><span class="mord">2</span><span class="mord">3</span><span class="mord"><span class="mord">9</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span></p>
<h3 id="переполнение-a-name--overflowa">Переполнение <a></a></h3>
<p>У каждой переменной будь она целочисленная или с плавающей точкой есть память, которую она занимает. Метод хранения и объем этой памяти напрямую влияют на то какие числа туда можно помещать.<br>
Допустим, что в ячейке размером 4 бита лежит число 15 (максимально возможное).<br>
<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>111</mn><msub><mn>1</mn><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">1111_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.79444em; vertical-align: -0.15em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span><br>
Если мы попробуем прибавить к этому числу 1, то по логике должны получить 16, но т.к. на хранение выделено только 4 бита, мы получаем 0.<br>
<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mi mathvariant="normal">∣</mi><mn>111</mn><msub><mn>1</mn><mn>2</mn></msub><mo>+</mo><mn>1</mn><mo>=</mo><mn>1</mn><mi mathvariant="normal">∣</mi><mn>000</mn><msub><mn>0</mn><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">0|1111_2+1=1|0000_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">0</span><span class="mord">∣</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span class="mord">∣</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span></span></span></span></span></p>
<h3 id="битовые-операции-над-целыми-числами-и-их-применения.-a-name--integersa">Битовые операции над целыми числами и их применения. <a></a></h3>
<p>Набор битовых операция будет очень сильно напоминать набор логических. Разница лишь в том, что битовые операции можно применять к <strong>целым</strong> числам.</p>
<ul>
<li>AND -  &amp;</li>
<li>OR - |</li>
<li>NOT - ~</li>
<li>XOR - ^</li>
<li>Сдвиг влево &lt;&lt;</li>
<li>Сдвиг вправо &gt;&gt;</li>
</ul>
<p>При использовании все эти операторы будут возвращать число, полученное <strong>побитовым</strong> применением соответствующей логической операции к битам параметров.<br>
Например:</p>
<pre><code>cout &lt;&lt; (255 &amp; 1);//1
cout &lt;&lt; (255 | 0);//255
cout &lt;&lt; (255 ^ 128);//127
cout &lt;&lt; (~0);//-1
</code></pre>
<h4 id="сдвиг-влево-и-сдвиг-вправо">Сдвиг влево и сдвиг вправо</h4>
<p>Сдвиг влево и сдвиг право — <s>внезапно</s>  побитово сдвигают число влево или в право, тем самым умножая (&lt;&lt;) или деля (&gt;&gt;) его на 2. Является “быстрым” целочисленным умножением/делением на 2.</p>
<h2 id="условный-оператор.a-name--ifa">Условный оператор.<a></a></h2>
<h3 id="конструкции-if-и-if-else.-a-name--if-elsea">Конструкции if и if else. <a></a></h3>
<p>В языке С++ существуют конструкции, которые называются условиями.<br>
Они записываются как <code>if</code>:</p>
<pre><code>if(true)
{
	//код выполняется
}
if(false)
{
	//код НЕ выполняется
}
</code></pre>
<p>Условие состоит из нескольких частей:</p>
<pre><code>if(условие)
{
	тело условия - часть программы, которая будет 
	выполняться исключительно при истинности условия.
}
</code></pre>
<p>Пример:</p>
<pre><code>cin &gt;&gt; x;
if(x % 2 == 0)
{
	cout &lt;&lt; "X is even!";
}
else 
{
	cout &lt;&lt; "X is odd!";
}
</code></pre>
<p>Часть программы заключенная между фигурными скобками  { } называется <em><strong>БЛОКОМ КОДА</strong></em></p>
<p>После блока условия можно воспользоваться конструкцией <code>else</code>, блок кода, относящийся к нему, будет исполняться только при условии, что условие в <code>if</code> было <strong>ложным</strong>.<br>
Таким же образом можно составлять достаточно длинные и сложные конструкции с <code>else if</code>.<br>
Например:</p>
<pre><code>if(apple == "green")
{
	cout &lt;&lt; "This apple is GREEN!";
}
else if(apple == "red")/*Здесь можно было бы обойтись и без else,
 но тогда программе бы пришлось выполнять много ненужных сравнений.*/
{
	cout &lt;&lt; "This apple is RED!";  
}
else if (apple == "orange")
{
	cout &lt;&lt; "This apple is not an apple at all!";
}
else 
{
	cout &lt;&lt; "It`s a banana &gt;:D";
}
</code></pre>
<p>Вы можете ставить <strong>сколько угодно</strong> <code>else if</code> после <code>if</code>, но <code>else</code> может быть только <strong>один</strong> и должен стоять на <strong>последнем месте</strong>.</p>
<h3 id="вложенные-условные-операторы.-a-name--if-ifa">Вложенные условные операторы. <a></a></h3>
<p>При необходимости обрабатывать длинные и сложные условия вы можете “вкладывать” условные конструкции друг в друга.<br>
Например:</p>
<pre><code>if(shape == "sphere")
{
	if(color == "blue")
	{
		cout &lt;&lt; "It`s a fat whale!";
	}
	else if (color == "green")
	{
		cout &lt;&lt; "It's a watermelon!";
	}
}
else if (shape == "cube")
{
	cout &lt;&lt; "It`s a box!";
}
</code></pre>
<h3 id="объединение-условий-and-or-not.-a-name--if-and-ora">Объединение условий (and, or, not). <a></a></h3>
<p>Так как в условие для <code>if</code> можно записать любое логическое тождество, то для составления сложных условий нужно пользоваться логическими операторами для того, что бы не сильно увеличивать вложенность и улучшить читабельность.  Запишем проверку <code>Число Х делится на 3, на 5 или не делится на 10</code>.<br>
Без составного условия:</p>
<pre><code>if(x % 3 == 0)
{
	if(x % 5 == 0)
	{
		//ваш код
	}
	else if(x % 10 != 0)
	{
		//ваш код
	}
}
else if(x % 10 != 0)
{
	//ваш код
}
</code></pre>
<p>С составным условием:</p>
<pre><code> if(x % 3 == 0 &amp;&amp; x % 5 == 0 || x % 10 != 0)
 {
	 //ваш код
 }
</code></pre>
<p>Вопросов “Зачем?” возникать не должно…</p>
<p>При проверке длинной “колбасы” из условий, разделённых с помощью операции <code>||</code>, программа <strong>прекратит проверку</strong> и зайдёт в блок при первой встрече значения <code>ИСТИНА</code>. Аналогично и для операции <code>&amp;&amp;</code> и значения <code>ЛОЖЬ</code> — программа <strong>прекратит расчёт</strong> следующих условий, и вход выполнен не будет.</p>
<p>Пример:</p>
<pre><code>if(true &amp;&amp; (true||...) &amp;&amp; false &amp;&amp; ...)/*с помощью многоточий
 показаны места, которые не будут рассчитаны*/
{
}
</code></pre>
<h3 id="оптимизация-логических-выражений-компилятором-false-and-x-true-or-y.-a-name--if-opta">Оптимизация логических выражений компилятором (false and X, true or Y). <a></a></h3>
<p>В случае, когда результат выражения в условии <em>известен до запуска программы</em>, компилятор может <strong>упростить</strong> всё условие или даже весь блок кода.<br>
Пример:</p>
<pre><code>if(true || x &lt; 10 &amp;&amp; x &lt;93021 &amp;&amp; false)
{
	//всегда будет выполняться
}
</code></pre>
<h3 id="оператор-case.-a-name--casea">Оператор Case. <a></a></h3>
<p>Существует ещё одна конструкция, позволяющая обрабатывать условия.</p>
<pre><code>switch (x)
{
case 1:
	cout &lt;&lt; "X == 1";
	break;
case 2:
	cout &lt;&lt; "X == 2";
	break;
case 3:
	cout &lt;&lt; "X == 3";
	break;
default:
	cout &lt;&lt; "X != 1, 2, 3.";
};
</code></pre>
<p>В скобках у <code>switch</code> указываем переменную, значения которой хотим обрабатывать. И дальше перечисляем необходимые значения этой переменной в <code>case</code>.  <code>default</code> будет выполняться, если <strong>ни одно</strong> условие не было выполнено.<br>
<em><strong>Важно</strong></em> : если не ставить <code>break;</code> после необходимых вам операций, то выполнение пойдёт просто “вниз” до первого <code>break;</code>.</p>
<pre><code>x = 1;
switch(x)
{
	case 1:
		cout &lt;&lt; 1;
	case 2:
		cout &lt;&lt; 2;
		break;
	case 3:
		cout &lt;&lt; 3;
};  
</code></pre>
<p>Вывод программы будет <code>12</code>.</p>
</div>
</body>

</html>
